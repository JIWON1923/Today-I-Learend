# 07. 메모리

### 메모리의 종류

#### 메모리의 종류

💡 아래로 내려갈 수록 가격이 싸고, 속도가 느리다. 왜 여러개가 필요한지 알아보자!

* 레지스터
* 캐시
* 메인메모리 (RAM)
* 보조저장장치 (HDD, SSD)

#### 레지스터

* 가장 빠른 기억장소로, CPU내부에 존재한다.
* 휘발성 메모리이다. (전원이 공급되지 않으면 데이터가 사라진다.)
* 레지스터의 크기 = CPU의 bit수이다. (32bit, 64bit)
* CPU에서 계산을 할 때, 메인 메모리에 있는 값을 레지스터로 가져와서 계산한 후 결과를 다시 메인 메모리에 저장한다.

#### 캐시

* CPU 내부에 존재하며, 레지스터와 메인메모리 사이에 존재한다.
*   레지스터는 CPU가 사용하는 메모리로 매우 빠르지만, 메인 메모리는 상대적으로 매우 느리다.

    → 메인 메모리에 있는 값을 레지스터로 가져올 때 너무 오래걸려서, 캐시라는 공간에 데이터를 미리 로드해 놓는 것이다.
* 속도 별로 L1, L2 .. 가 존재하며, 캐시에서 데이터를 모두 찾아보고, 없다면 메인메모리에서 값을 가져오게 된다.

#### 메인메모리

* 실제 운영체제와 다른 프로세스들이 올라가는 공간이다.
* 휘발성 메모리이다. (전원이 공급되지 않으면, 지워진다)
* HDD나 SSD보다 빠르지만, 가격이 비싸서 데이터를 저장하는 것 보다는 실행중인 프로그램만 올린다.

#### 보조 저장 장치

* 가격이 저렴하며, 비휘발성 메모리이다. (속도가 느리다)

💡 여러 종류의 메모리를 두고, 가격과 속도를 절충하여 저렴하고 빠른 컴퓨터를 이용할 수 있게 되었다.

***

### 메모리와 주소

#### 주소

* 오늘날 컴퓨터는 폰 노이만 구조로 모든 프로그램을 메모리에 올려서 실행시킨다.
  * 멀티 프로그래밍 환경에서 메모리에 여러 개의 프로세스가 올라오니 관리가 복잡하고 어려워졌다.
* 운영체제가 메모리를 관리하기 위해서 1Byte 크기로 구역을 나누고 숫자를 매기게 된다. 이를 주소라고 한다.
* 즉, 주소는 멀티 프로그래밍 환경에서 원활하게 메모리를 관리하기 위해서 사용하게 된 체계이다.

> 참고! 32bit와 64bit
>
> * 32Bit CPU
>   * 레지스터 크기, ALU(산술 능력 연산 장치), 버스(데이터이동)이 32bit이다.
>   * CPU가 다룰 수 있는 메모리 = 2^32 = 4GB
> * 64Bit CPU
>   * 레지스터 크기, ALU(산술 능력 연산 장치), 버스(데이터이동)이 64bit이다.
>   * CPU가 다룰 수 있는 메모리 = 2^64 = 거의 무한대
>
> 즉, 64bit CPU가 한 번에 처리할 수 있는 양이 더 많기 때문에 속도가 더 빠르다.

#### 물리주소와 논리주소

💡 실제 메모리의 주소가 물리주소이며, 사용자 관점에서 바라보는 주소는 논리주소라고 한다. 사용자는 물리주소를 모르더라도, 논리주소를 통해 물리주소로 접근할 수 있다.

* 경계 레지스터
  * 메모리에 프로세스와 운영체제가 올라가게 된다. 만약, 사용자 프로세스가 운영체제의 영역을 침범하게 되면, 위험할 수 있다. 이를 하드웨어적으로 분리하기 위해 경계 레지스터를 두게 된다.
  * CPU 내에 존재하며, 메모리 관리자는 사용자 프로세스가 경계 레지스터 값을 벗어났는지 검사한다. 만약 벗어났다면, 해당 프로세스를 종료시키게 된다.

#### 절대주소와 상대주소

💡 절대주소(물리주소) 상대주소(논리주소)

* 개발자는 프로그램이 실제로 실행될 주소를 신경쓰지 않는다. (컴파일러는 프로그램을 0번째에서 실행시킨다고 가정한다) → **상대주소**
* 실제 프로그램이 실행되었을 때 올라가는 주소 = 메모리 관리자가 바라보는 **절대주소**
  *   실제 프로그램이 4000번째에 올라갔다고 가정한다.

      개발자 : 100번째에 있는 데이터 요청

      CPU : 100번째에 있는 데이터 요청

      메모리 관리자 : 100번지와 재배치 레지스터에 있는 4000을 더해서 4100째에 있는 데이터 전달
  * 재배치 레지스터 : 프로그램의 실행 주소가 저장되어있다.
  * 메모리 관리자 덕분에, 모든 사용자 프로세스는 0번지로 가정하여 사용할 수 있다. (시작 영역이 바뀌면 재배치 레지스터 값만 바꾸면 되기 때문에 굉장히 유연하다.)

***

### 메모리 할당 방식

#### 유니 프로그래밍 환경

* 유니 프로그래밍 환경에서, 가지고있는 메모리보다 더 큰 프로그램을 실행시키기 위해 **메모리 오버레이** 기법을 사용했다.
  * 큰 프로그램을 메모리에 올릴 수 있도록 잘라서, 당장 실행시켜야할 부분만 메모리에 올리며, 나머지는 HDD(스왑 영역)에 저장하는 기법이다.
  * 메모리에 1GB, 스왑 여역에 8GB가 저장되어있다면 사용자는 9GB처럼 사용할 수 있다. 하지만 스왑 과정이 존재하므로 실메 메모리가 9GB인 컴퓨터보다는 느리게 동작한다.
    * 스왑과정은 스왑 영역에 있는 데이터 일부를 메모리에 가져오고, 메모리에 있는 데이터를 스왑 영역으로 옮기는 과정이다.

#### 멀티 프로그래밍 환경

💡 메모리에 여러 프로세스가 올라오기 때문에, 메모리를 나누어 관리하게 된다.

* 가변 분할 방식 (**세그멘테이션**)
  * 프로세스의 크기에 따라 메모리를 나눈다.
  * 한 프로세스가 메모리의 연속된 공간에 할당되어 **연속 메모리 할당**이라고 한다.
  * 내부 단편화는 없지만, **외부 단편화**가 발생한다.
* 고정 분할 방식 (**페이징**)
  * 메모리를 정해진 크기로 나누어 프로세스 크기와 상관 없이 메모리를 할당한다.
  * 하나의 프로세스가 메모리에 분산되어 저장되어 **비연속 메모리 할당**이라고 한다.
  * 구현이 간단하지만, **내부 단편화**가 발생한다.

#### 단편화?

1. 내부 단편화
   * 메모리가 남는 문제이다.
   * 작은 프로세스가 큰 영역의 메모리에 할당되어 메모리가 낭비되는 문제이다.
   * 고정분할 방식에서 메모리의 분할되는 크기를 조절하여 내부단편화를 최소화할 수 있다.
2. 외부 단편화
   * 가변 분할 방식에서 특정 프로세스가 종료되면, 빈 공간이 생기게 된다.
   * 하지만 이 공간들이 분산되어있는 경우, 메모리에 공간이 있음에도 불구하고 특정 프로세스가 연속된 공간이 아니므로 실행시키지 못하는 경우가 발생할 수 있다.
   * 조각모음을 통해 이 문제를 해결할 수 있지만, 실행되는 모든 작업을 일시중지시키고, 이동시켜야하는 오버헤드가 발생한다.

#### 버디시스템 (가변 + 고정의 혼합)

* 메모리를 2의 승수로 분할하여 메모리를 할당하는 방법이다.
* 프로세스가 종료된 후에 근접한 메모리 공간을 합치기 쉽다. (조립만 하면 큰 메모리를 만들 수 있다)
* 가변 분할 방식처럼 프로세스 크기에 따라 할당되는 메모리의 크기가 달라지며, 외부 단편화를 방지하기 위해 메모리 공간을 확보한느 것이 간단하다.
* 고정 분할 방식처럼 내부 단편화가 발생하기는 하지만, 많은 공간의 낭비가 발생하지는 않는다.
