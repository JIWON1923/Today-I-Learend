# 운영체제의 개요

## 운영체제가 하는 일

1.  프로세스 관리

    * 여러개의 프로그램을 동시에 실행시킬 수 있도록 관리해주는 것이다.

    > 우리는 컴퓨터에서 노래를 들으면서, 게임을 동시에 할 수 있다. 이때 키보드와 마우스는 게임에만 반응하며, 브라우저나 음악은 백그라운드에서 동작한다. (만약 그렇지 않다면, 게임이 내 입력에 제대로 동작하지 않거나, 음악이나 브라우저는 실행조차 안 될 것이다.)
2. 메모리 관리
   * 여러 프로그램을 메모리에서 관리하는 방법이다.
3. 하드웨어 관리
   * 하드웨어에 대한 직접적인 접근을 막는다.
     *   운영체제가 판단해서 적절한 위치에 저장한다.

         → 사용자의 악의적인 공격을 방지할 수 있고, 중요한 정보가 덮어씌워지는 것을 방지한다.
4. 파일 시스템 관리



## 운영체제의 역사

### 1940년대: 컴퓨터의 탄생

* 세계 최초의 컴퓨터 애니악이 탄생한다.
  * 미사일 탄도 계산을 위한 전자 디지털 계산기이다.
  * 특정 명령을 실행하기 위해 해당 배선을 사람이 직접 연결해 작동시켰다.
  * 입출력은 IBM 펀치 카드를 사용했다.
  * 언제 터질지 모르는 진공관을 사용했다.
  * 하드웨어 비용이 비싸서 CPU를 많이 사용하고 싶어했다. (당시 인건비는 매우 저렴해서 고려 대상이 아니었다.)

### 1950년대 초, 직접 회로의 개발

* 직접 회로가 개발되었다. (IC)
  * CPU와 메모리는 존재했으나, 여전히 입출력은 IBM 펀치카드를 사용했다.
* 사용 프로세스
  * 펀치카드를 이용해서 입력 → 오퍼레이터에게 전달 → 라인프린터를 통한 결과 확인
  * 오퍼레이터에게 처리를 요청하는 시간이 너무 오래걸린다고 느꼈다. (너무 큰 오퍼레이터의 오버헤드)

### 1950년대 중 후반, 싱글스트림 배치시스템의 탄생

* 싱글 스트림 배치 시스템의 탄생
  * 프로그래머가 여러 개의 펀치 카드를 한 번에 전달 → 오퍼레이터가 CPU에 펀치카드를 순차적으로 실행 후 결과를 한 번에 프로그래머에게 전달하는 것
  * 결과가 나올 때마다 전달하는 과정이 없어지면서 CPU의 사용률이 올라갔다.
    * 그럼에도 입력이나 출력하는 시간 동안 CPU가 놀고 있었다.
* I/O 디바이스 컨트롤러의 탄생
  * 입출력을 담당하는 것으로, 맡은 작업이 끝나면 CPU에게 인터럽트 신호를 주고, 인터럽트를 받은 CPU가 다시 처리하는 방식으로 발전했다.
  * 하지만 입력을 처리하는 경우 한계가 존재했다.
    * 어떤 작업에서 사용자의 입력을 받아서 처리해야하는 경우, CPU를 기다려야하므로 CPU 사용률이 떨어졌다. (싱글 스트림 배치 시스템의 한계)
    * 출력의 경우 CPU가 종속적이지 않아 I/O 디바이스 컨트롤러에 의해 CPU와의 분리가 가능했다.

### 1960, 시분할 시스템의 탄생

* 싱글스트림 배치시스템의 한계를 극복한 시분할 시스템의 탄생
  * 메모리에 여러 프로그램을 올리고, 시간을 나누어서 빠르게 돌아가며 실행시키는 방법
    * 기존에는 입력이 있을 때, CPU가 기다려야했지만, 시분할 시스템에서는 다른 프로그램을 작업하게 되면서 CPU의 사용률이 증가했다.
  * 여러 프로그램을 실행시킬 수 있게 되었다.
    * 여러 사용자가 한 번에 사용할 수 있게 되었다.
    * 사용자 입장에서 프로그램들이 동시에 실행되는 것처럼 느꼈다.
  * 당시 비싼 가격 때문에 하나의 컴퓨터를 여러 사용자들이 여러 터미널로 접근해서 사용했었다.
    * 시분할 시스템의 등장으로, 각 사용자들은 하나의 컴퓨터를 각자 사용하는 것 처럼 느끼기 시작했고, 개인 문서 등 개인 정보를 저장하면서 파일 시스템이 등장하게 되었다.

### UNIX 운영체제의 개발

1. UNIX 운영체제의 기능
   1. 멀티 프로그래밍
   2. 다중 사용자
   3. 파일 시스템
2. 1960년대 = 멘붕의 시대
   * 여러 프로그램이 동시 실행되면서 많은 문제가 발생했다.
     *   메모리 침범 이슈

         → A프로그램이 B프로그램에 침범하기도 했고, 심지어 OS에 침범하는 경우도 발생했다.
     *   프로그래밍의 변화

         → 기존에는 하나의 메모리에 하나의 프로그램이 동작했기 때문에, 신경쓰지 않아도 되었으나, 메모리에 여러 프로그램이 올라가면서 프로그램 시작 메모리의 변화가 생겼다. → Base register를 통해 모든 프로그램이 0번째에서 실행된다고 가정하고 프로그래밍을 하게 되었다.
     * 많은 문제가 발생하며, 학문으로 자리잡기 시작했다.

### 1970년대, 개인용 컴퓨터 시대

* 컴퓨터 가격이 낮아지면서, 개인이 소유하기 시작했다.
  * Apple의 맥킨토시나 마이크로소프트의 \_를 많이 사용했다.



## 운영체제의 구조

### 커널

* 운영체제에서 가장 중요한 핵심 부분이다.
* 사용자나 프로그램이 직접 하드웨어에 접근할 수 없다.
* 인터페이스나 시스템 콜을 통해 접근해야한다.

### 접근 방법 (인터페이스와 시스템 콜)

* 인터페이스
  * 사용자가 커널에 접근하기 위한 방법으로 GUI와 CLI가 존재한다.
  * GUI의 경우 Graphic User Interface의 약자로, 현재 mac OS, windows 등에 해당한다.
  * CLI의 경우 Unix terminal 등..
* 시스템 콜
  * 프로그램이 직접적으로 하드웨어에 접근하면 문제가 발생할 수 있다.
    * 정보가 사라질 수 있다.

### 드라이버

* 커널은 매우 중요한 역할을 하기도 하고, 메모리는 한정적이기 때문에 모든 I/O를 제어할 수 있는 것을 저장해놓지 않는다.
* 이에 필요한 것들을 드라이버를 통해 제어할 수 있도록 되어 있다.



## 컴퓨터 하드웨어와 구조

### 폰 노이만 구조

* 컴퓨터의 하드웨어는 폰 노이만 구조로 되어있다. (제안한 학술자 이름임)
  * 메인보드 안에 CPU / 메모리 어쩌고

### CPU

1. CPU의 구조
   1. 산술논리 연산장치
   2. 제어장치
   3. 레지스터
2. 각 장치의 역할
   1. 산술논리 연산장치
   2. 제어 장치
   3. 레지스터

### 메모리

* 메모리는 RAM, ROM으로 구성되어있다.
  * RAM
    * 휘발성 메모리이다.
    * 중요한 정보들?
    * 어떤 위치에 있든지, 불러오는 데에 동일한 읽기 및 저장 속도를 가진다.
  * ROM
    * 비휘발성 메모리이다.
    * 부팅과 관련된 정보들을 저장한다.



## 컴퓨터의 부팅 과정

1. ROM 메모리를 불러온다.
2. 여러개의 OS가 있다면, 선택
3. OS를 메모리에 올린다. (RAM)
   1. 오류 발생시 부팅 실해
   2. 오류 없으면 정상 작동
